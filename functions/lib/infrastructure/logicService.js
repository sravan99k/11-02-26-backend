"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateScoresByDomain = exports.mapScoreToBloomState = exports.getPhaseEncouragement = exports.evaluateRule = void 0;
const evaluateRule = (rule, responses) => {
    if (!rule)
        return false;
    const tokens = rule.split(' ');
    if (tokens.length === 3) {
        const [id, op, val] = tokens;
        const resp = responses.find(r => r.questionId === id);
        if (!resp)
            return false;
        const actualVal = resp.score !== undefined ? resp.score : resp.answer;
        const targetVal = isNaN(Number(val)) ? val.replace(/'/g, '') : Number(val);
        switch (op) {
            case '>=': return actualVal >= targetVal;
            case '<=': return actualVal <= targetVal;
            case '==': return actualVal === targetVal;
            case '>': return actualVal > targetVal;
            case '<': return actualVal < targetVal;
            default: return false;
        }
    }
    if (rule.includes('||')) {
        return rule.split('||').some(part => (0, exports.evaluateRule)(part.trim(), responses));
    }
    if (rule.includes('&&')) {
        return rule.split('&&').every(part => (0, exports.evaluateRule)(part.trim(), responses));
    }
    return false;
};
exports.evaluateRule = evaluateRule;
const getPhaseEncouragement = (phase) => {
    const phases = {
        1: { title: "Sowing Season", focus: "Finding your roots and settling in." },
        2: { title: "Growing Rays", focus: "Balancing your energy and shining your light." },
        3: { title: "Winter Whisper", focus: "Gathering warmth and caring for your spirit." },
        4: { title: "The Harvest", focus: "Reflecting on your beautiful journey." }
    };
    return phases[phase] || phases[1];
};
exports.getPhaseEncouragement = getPhaseEncouragement;
const mapScoreToBloomState = (score) => {
    if (score <= 30) {
        return {
            state: "Brilliant Bloom",
            description: "You're showing incredible resilience and positivity. Keep nurturing your inner garden!",
            color: "#10b981",
            icon: "sun"
        };
    }
    else if (score <= 60) {
        return {
            state: "Steady Growth",
            description: "You're navigating things well. A few clouds here and there, but you're growing stronger every day.",
            color: "#3b82f6",
            icon: "cloud-sun"
        };
    }
    else {
        return {
            state: "Needs Gentle Care",
            description: "It looks like things are a bit heavy right now. Just like a plant after a storm, you might need a little extra support and sunshine.",
            color: "#f59e0b",
            icon: "cloud-rain"
        };
    }
};
exports.mapScoreToBloomState = mapScoreToBloomState;
const calculateScoresByDomain = (questions, responses) => {
    var _a;
    const scores = {};
    responses.forEach(resp => {
        const q = questions.find(q => q.id === resp.questionId);
        if (!q)
            return;
        const mainDomain = q.domain || 'General';
        const subDomain = q.subdomain || 'General';
        const qMax = 4;
        if (!scores[mainDomain]) {
            scores[mainDomain] = { total: 0, max: 0, subdomains: {} };
        }
        if (!scores[mainDomain].subdomains[subDomain]) {
            scores[mainDomain].subdomains[subDomain] = { total: 0, max: 0 };
        }
        const score = resp.score;
        scores[mainDomain].total += score;
        scores[mainDomain].max += qMax;
        scores[mainDomain].subdomains[subDomain].total += score;
        scores[mainDomain].subdomains[subDomain].max += qMax;
        if (!scores['overall']) {
            scores['overall'] = { total: 0, max: 0, subdomains: {} };
        }
        scores['overall'].total += score;
        scores['overall'].max += qMax;
    });
    const result = {};
    Object.entries(scores).forEach(([domain, data]) => {
        result[domain] = {
            score: data.max > 0 ? Math.round((data.total / data.max) * 100) : 0,
            subdomains: {}
        };
        Object.entries(data.subdomains).forEach(([sub, subData]) => {
            result[domain].subdomains[sub] = subData.max > 0
                ? Math.round((subData.total / subData.max) * 100)
                : 0;
        });
    });
    result.overallScore = ((_a = result.overall) === null || _a === void 0 ? void 0 : _a.score) || 0;
    return result;
};
exports.calculateScoresByDomain = calculateScoresByDomain;
//# sourceMappingURL=logicService.js.map